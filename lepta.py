import copy
import random
"""
СЧИТЫВАЕМ ДАННЫЕ

field[j][i]  - массив хранит сами символы
state[j][i] - массив состояния: хранит 11 вместо "х", 13 вместо "о" и 0 вместо "."

"""

field = []
state = []
for i in range(4):
    state.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
with open ("data.txt") as f:
    for line in f:
        q= [x for x in line.split()] 
        s = [0, 0, 0, 0]
        for i in range (20):
            if q[i] == 'x':
                s.append(11)
            if q[i] == 'o':
                s.append(13)   
            if q[i] == '.':
                s.append(0)
        for k in range(4):
            s.append(0)
        state.append(s)    
        field.append(q)
        
for i in range(4):
    state.append([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])



"""
ВЫСЧИТЫВАЕМ СЛЕДУЮЩИЙ ХОД
data[j][i] - массив хранит параметры выгодности хода для каждой клетки
coords_x - массив хранит сведения о координатах наиболее выгодных с точки зрения ОБОРОНЫ клеток
coords_o - массив хранит сведения о координатах наиболее выгодных с точки зрения АТАКИ клеток
glob_max_x - глобальный максимум крестиков по всем пятеркам поля
glob_max_o - глобальный максимум ноликов по всем пятеркам поля
J, I - координаты клетки, в которую будет поставлен нолик
"""


data = copy.deepcopy(state)

coords_x = [] 
coords_o = []
glob_max_x = 0
glob_max_o = 0
numb_max_x = 0
numb_max_o = 0


J = 0
I = 0


for j in range(4, 24):
    for i in range(4, 24):
        """
        j, i  - координаты клетки на поле
        char_five - для текущей пятерки ее характеристическая сумма
        a = [колво_пятерок_крест, колво_пятерок_нулей, макс_крест, макс_колво_крестов, макс_нулей, макс_колво_нулей] 
        """
        
        a = [0, 0, 0, 0, 0, 0]
        
        for v in range(0, 5):
            """
            для 5 вертикальных пятерок заполняем массив a
            """
            beg = i - 4 + v
            char_five = 0
            if state[j][i] == 0:
                for p in range(0, 5):
                    char_five += state[beg+p][i]
            
            if (char_five%11 == 0) and (char_five != 0):
                a[0] += 1 
                if char_five//11 > a[2]:
                    a[2] = char_five//11
                    a[3] = 0
                if char_five//11 == a[2]:
                    a[3] += 1
            if (char_five%13 == 0) and (char_five != 0):
                a[1] += 1
                if char_five//13 > a[4]:
                    a[4] = char_five//13
                    a[5] = 0
                if char_five//13 == a[4]:
                    a[5] += 1          
            
            
        for v in range(0, 5):
            """
            для 5 горизонталых пятерок заполняем массив a
            """
            beg = j -4 + v
            char_five = 0          
            if state[j][i] == 0:
                for p in range(0, 5):
                    char_five += state[j][beg+p]
                
            if (char_five%11 == 0) and (char_five != 0): 
                a[0] += 1
                if char_five//11 > a[2]:
                    a[2] = char_five//11
                    a[3] = 0
                if char_five//11 == a[2]:
                    a[3] += 1
            if (char_five%13 == 0) and (char_five != 0):
                a[1] += 1
                if char_five//13 > a[4]:
                    a[4] = char_five//13
                    a[5] = 0
                if char_five//13 == a[4]:
                    a[5] += 1
        
        
        for v in range(0, 5):
            """
            для 5 главно-диагональных пятерок заполняем массив a
            """
            begi= i -4 + v
            begj= j -4 + v
            char_five = 0
            if state[j][i] == 0:
                for p in range(0, 5):
                    char_five += state[begj+p][begi+p]
                
            if (char_five%11 == 0) and (char_five != 0):
                a[0] += 1
                if char_five//11 > a[2]:
                    a[2] = char_five//11
                    a[3] = 0
                if char_five//11 == a[2]:
                    a[3] += 1
            if (char_five%13 == 0) and (char_five != 0):
                a[1] += 1
                if char_five//13 > a[4]:
                    a[4] = char_five//13
                    a[5] = 0
                if char_five//13 == a[4]:
                    a[5] += 1          
        
        
        for v in range(0, 5):
            """
            для 5 побочно-диагональных пятерок заполняем массив a
            """
            begi= i +4 - v
            begj= j -4 + v
            char_five = 0
            if state[j][i] == 0:
                for p in range(0, 5):
                    char_five += state[begj+p][begi-p]
               
            if (char_five%11 == 0) and (char_five != 0):
                a[0] += 1
                if char_five//11 > a[2]:
                    a[2] = char_five//11
                    a[3] = 0
                if char_five//11 == a[2]:
                    a[3] += 1
            if (char_five%13 == 0) and (char_five != 0):
                a[1] += 1
                if char_five//13 > a[4]:
                    a[4] = char_five//13
                    a[5] = 0
                if char_five//13 == a[4]:
                    a[5] += 1   
                    
        if glob_max_x < a[2]:
            glob_max_x = a[2]
         
            
            coords_x = []
            
            
        if glob_max_o < a[4]:
            glob_max_o = a[4]
            coords_o = []
            
            
        if a[2] == glob_max_x:
            coords_x.append([j, i])
            
        if a[4] == glob_max_o:
            coords_o.append([j, i])
            
        data[j][i] = a    
            
if glob_max_o == 4:
    n = random.randint(len(coords_o))
    J = coords_o[n] [1]
    I = coords_o[n] [2]
    
#if glob_max_x > glob_max_o:
    #if glob_max_o == 4:
    #n = random.randint()
    #J = coords_o[n] [1]
    #I = coords_o[n] [2]
    
            
            

"""
Оно не дописано. 

Идея (кратко):
 для каждой клетки рассматриваются всевозможные пятерки (их 20)
 в которых она участвует. Для каждой пятерки рассчитывается количество крестиков в них,количество
 ноликов в них. Для каждой клетки определяется максимум крестиков в принципе по пятеркам и максимум ноликов (запоминаются).
 Далее для каждой клетки находится количество 
максимумов по пятеркам по крестикам и аналогично по ноликам.
В рассмотрении остаются два массива клеток: первый массив состоит из клеток, для которых кол-во крестиков в какой-то из их 20 пятерок
максимально вообще по всем клеткам и пятеркам поля (например, в какой-то пятерке 3 крестика)  и (одновременно) максимально количество максимумов
 (т.е., например, максимум равен 3 у многих клеток, но мы хотим рассматривать только те клетки, у которых максимально количество пятерок с 3 крестиками).
 Второй массив состоит и клеток, у которых аналогичное с ноликом. Эти два массива - потенциальные ходы.
Далее нужно сравнивать максимумы крестиков (4, 3, 2, 1) и ноликов (4, 3, 2, 1).
Собственно, примерно до сих пор и реализовано.
Например, если у максимум по крестикам равен 4 и по ноликам тоже, то ход совершается в рандомную клетку с максимумов 4 по ноликам.
Случаи, когда максимум равен 3 требуют наибольшего количества костылей. В большинстве случаев будет происходить защита (т.е. в случаях оо_о; ооо_; ...)
Если максимумы меньше трех, то должна происходить атака: ход совершается в клетку с максимумом по ноликам.

Здесь данные считываются из файла, предполагалось, что ход будет выведен в тот же файл (замена одной из точек на нолик).

Ну типа она вообще-то ничего не выводит, потому что просто код не дописан.
"""





